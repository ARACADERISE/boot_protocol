org 0x7C00
use16

struc mbr_partition_table_entry
	; Is this MBR partition table entry bootable?(is it describing the rest of the bootloader?)
	; 0x80 = bootable, 0x0 = not bootable
	.is_bootable:									resb 0x01
	; From what sector does the program begin(lower 8-bits)
	; With this, the sector where the program begins has to be the sector where the last program ended off
	; So, for a program after the MBR, `first_sector` would be 2
	; From what cylinder does the sector reside on?(upper 8-bits)
	.starting_sector_and_cylinder:					resw 0x01
	; 0x05/0x0F for extended partition table
	; Any other value has yet to be determined
	.entry_type:									resb 0x01
	; If this is `1`, the MBR partition table C program will automatically read in
	; the needed amount of memory. If `0`, the MBR partition table C program will not load
	; anything into memory.
	; This is going to be more helpful later on. With this, we can primarily mark certain
	; partitions in the extended partition table as "critical", thus, the protocol MUST
	; read the programs residing in each partition into memory AND run them
	.auto_read_program:								resb 0x01
	; From what sector does the program end?(lower 8-bits)
	; From what cylinder does the last sector reside on?(upper 8-bits)
	.last_sector_and_cylinder:						resw 0x01
	; Just set this to zero lol
	.relative_sector:								resd 0x01
	; How many sectors does the program obtain?
	; This amount * 512 will be added to `bprogram_address` to calculate the ending address
	; of the program
	.sector_amnt:									resd 0x01
	; Pad 1 byte
	.pad:											resb 0x01
endstruc

%%macro CreateEntry	8
mbr_partition_entry%%+%%1:	istruc mbr_partition_table_entry
	at mbr_partition_table_entry.is_bootable,					db %%2
	at mbr_partition_table_entry.starting_sector_and_cylinder,	db %%3
	at mbr_partition_table_entry.entry_type,					db %%4
	at mbr_partition_table_entry.auto_read_program,				db %%5
	at mbr_partition_table_entry.last_sector_and_cylinder,		dw %%6
	at mbr_partition_table_entry.relative_sector,				dd %%7
	at mbr_partition_table_entry.sector_amnt,					dd %%8
	at mbr_partition_table_entry.pad,							db 0x0
iend
%%endmacro

jmp 0x0:start

start:
	xor ax, ax
	mov es, ax
	mov ds, ax

	cli
	mov bp, 0x7C00
	mov sp, bp
	mov ss, ax
	sti

	; Read in program that works with the MBR partition table(located at 0x0500)
	xor ax, ax
	mov es, ax
	mov bx, 0x0500

	mov ah, 0x02
	mov al, 0x01
	mov ch, 0x00
	mov cl, 0x02
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Increment sector number
	mov ax, 0x01
	add [Info.sector], ax

	; Read in users second stage bootloader
	mov ax, [Info.second_stage_addr]
	mov es, ax
	xor bx, bx

	mov ah, 0x02
	mov al, [Info.second_stage_size]
	mov ch, 0x00
	mov cl, [Info.sector]
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Update sector number
	mov ax, [Info.second_stage_size]
	add [Info.sector], ax
	mov [Info.sector], ax

	; Read in users kernel
	mov ax, [Info.kernel_addr]
	mov es, ax
	xor bx, bx

	mov ah, 0x02
	mov al, [Info.kernel_size]
	mov ch, 0x00
	mov cl, [Info.sector]
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Update sector number one last time
	mov ax, [Info.kernel_size]
	add [Info.sector], ax

	; Store the value in a constant address(`sector_addr` = `0x5000`)
	mov ax, [Info.sector]
	mov [sector_addr], ax

	; Jump to program that works with the MBR partition table
	jmp 0x0500

	; Uh oh, something went wrong
	jmp failed

	; We shouldn't reach here, but if we do, hlt
	cli
	hlt

sector_addr equ 0x5000

; Extended read wasn't working so.. I came up with my own little way :)
Info:
	; Sector information
	.sector				db 0x02
	; Second stage information
	.second_stage_size	dw ((second_stageE - second_stage + 512) / 512)
	.second_stage_addr	dw 0x07E0
	.second_stage_loc	dw 0x7E00
	; Kernel information
	.kernel_size		dw ((kernelE - kernel) / 512)
	.kernel_addr		dw 0x0%lx
	.kernel_loc			dw 0x%lx

failed:
	mov ah, 0x0E
	mov al, 'F'
	int 0x10
.f_halt:
	jmp .f_halt

TIMES 0x01BE - $ + $$ db 0

; Describing extended partition table(System ID = 0xF)
; The extended partition table resigns after the MBR
;CreateEntry	1, 0, 2, sum, 0x0F, 0x01, 0, 1
CreateEntry 1, 0, 0x0002, 0x0F, 1, 0x0003, 0x0002, 0x01

; Perhaps we can use these 3 partitions as "extra"?
; Use these in place of reading in 5 sectors for an additional "pool of memory",
; as I have been wanting to add.
CreateEntry	2, 0, 0, 0, 0, 0, 0, 0
CreateEntry	3, 0, 0, 0, 0, 0, 0, 0
CreateEntry	4, 0, 0, 0, 0, 0, 0, 0

dw 0xAA55

mbr_partition_table_program: incbin "bin/mbr_partition_table.bin"
mbr_partition_table_program_end:

second_stage: incbin "%s"
second_stageE:

kernel: incbin "%s"
kernelE: