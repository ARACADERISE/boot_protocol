org 0x7C00
use16

struc mbr_partition_table_entry
	.Indicator:										resb 0x01
	.FirstHead:										resb 0x01
	.FirstSector:									resw 0x01
	.SystemID:										resb 0x01
	.LastHead:										resb 0x01
	.LastSector:									resw 0x01
	.RelativeSector:								resd 0x01
	.SectorsCount:									resd 0x01
endstruc

%%macro CreateEntry	9
mbr_partition_entry%%+%%1:	istruc mbr_partition_table_entry
	at mbr_partition_table_entry.Indicator,				db %%2
	at mbr_partition_table_entry.FirstHead,				db %%3
	at mbr_partition_table_entry.FirstSector,			dw %%4
	at mbr_partition_table_entry.SystemID,				db %%5
	at mbr_partition_table_entry.LastHead,				db %%6
	at mbr_partition_table_entry.LastSector,			dw %%7
	at mbr_partition_table_entry.RelativeSector,		dd %%8
	at mbr_partition_table_entry.SectorsCount,			dd %%9
iend
%%endmacro

jmp 0x0:start

start:
	xor ax, ax
	mov es, ax
	mov ds, ax

	cli
	mov bp, 0x7C00
	mov sp, bp
	mov ss, ax
	sti

	; Read in program that works with the MBR partition table(located at 0x0500)
	xor ax, ax
	mov es, ax
	mov bx, 0x0500

	mov ah, 0x02
	mov al, 0x01
	mov ch, 0x00
	mov cl, 0x02
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Increment sector number
	mov ax, 0x01
	add [Info.sector], ax

	; Read in users second stage bootloader
	mov ax, [Info.second_stage_addr]
	mov es, ax
	xor bx, bx

	mov ah, 0x02
	mov al, [Info.second_stage_size]
	mov ch, 0x00
	mov cl, [Info.sector]
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Update sector number
	mov ax, [Info.second_stage_size]
	add [Info.sector], ax
	mov [Info.sector], ax

	; Read in users kernel
	mov ax, [Info.kernel_addr]
	mov es, ax
	xor bx, bx

	mov ah, 0x02
	mov al, [Info.kernel_size]
	mov ch, 0x00
	mov cl, [Info.sector]
	mov dh, 0x00
	mov dl, 0x80
	int 0x13
	jc failed

	; Update sector number one last time
	mov ax, [Info.kernel_size]
	add [Info.sector], ax

	; Store the value in a constant address(`sector_addr` = `0x5000`)
	mov ax, [Info.sector]
	mov [sector_addr], ax

	; Jump to program that works with the MBR partition table
	jmp 0x0500

	; Uh oh, something went wrong
	jmp failed

	; We shouldn't reach here, but if we do, hlt
	cli
	hlt

sector_addr equ 0x5000

; Extended read wasn't working so.. I came up with my own little way :)
Info:
	; Sector information
	.sector				db 0x02
	; Second stage information
	.second_stage_size	dw ((second_stageE - second_stage + 512) / 512)
	.second_stage_addr	dw 0x07E0
	.second_stage_loc	dw 0x7E00
	; Kernel information
	.kernel_size		dw ((kernelE - kernel) / 512)
	.kernel_addr		dw 0x0%lx
	.kernel_loc			dw 0x%lx

failed:
	mov ah, 0x0E
	mov al, 'F'
	int 0x10
.f_halt:
	jmp .f_halt

TIMES 0x01BE - $ + $$ db 0

; Describing extended partition table(System ID = 0xF)
CreateEntry	1, 0, 0, Info.sector, 0xF, 0, 0, 0, 0

; Perhaps we can use these 3 partitions as "extra"?
; Use these in place of reading in 5 sectors for an additional "pool of memory",
; as I have been wanting to add.
CreateEntry	2, 0, 0, 0, 0, 0, 0, 0, 0
CreateEntry	3, 0, 0, 0, 0, 0, 0, 0, 0
CreateEntry	4, 0, 0, 0, 0, 0, 0, 0, 0

dw 0xAA55

mbr_partition_table_program: incbin "bin/mbr_partition_table.bin"
mbr_partition_table_program_end:

second_stage: incbin "../bin/second_stage.bin"
second_stageE:

kernel: incbin "../bin/kernel.bin"
kernelE: